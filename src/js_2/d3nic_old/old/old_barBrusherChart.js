"use strict";

import { barBrusher } from "./barBrusher.js"

/*
 *
 *	Bar chart with vertical bars and a nice brusher.
 *
 */
export function barBrusherChart() {
	/*
	 *	MAIN variables default values.
	 */
	let width,
		height = 150,
		padding = { top: 20, right: 40, bottom: 30, left: 40, inner: 0, outer: 0 },
		yMin, yMax,
		fn_color = (v, j, d, i) => d3.schemeCategory10[j],
		fn_areaOpacity = (v, j) => 1;

	/*
	 *	Variables related to the data default values.
	 */
	let fn_key = (d, i) => i,
		values = ["value"];


	let fn_xAxis = d3.axisBottom();
	let fn_yAxis = d3.axisLeft();


	/*
	 *	Callbacks for brush.
	 */
	let fn_brushingCallback = (keysExtent) => {}
	let fn_brushEndCallback = (keysExtent) => {} 


	/*
	 *	The datasets used.
	 */
	let fullData = [];


	/*
	 *	Internal functions.
	 */
	let fn_updateWidth;
	let fn_updateFullData;


	/*
	 *	Helper function.
	 */
	let fn_getYDomain = function() {
		let yExtent = d3.modExtent([
			d3.min(fullData, d => d3.min(values, v => Object.byString(d, v))),
			d3.max(fullData, d => d3.max(values, v => Object.byString(d, v)))
		]);
		return [ 
			isNaN(yMin) || yExtent[0] > yMin ? yExtent[0] : yMin,
			isNaN(yMax) || yExtent[1] < yMax ? yExtent[1] : yMax
		]		
	}

	/*
	 *	CORE function.
	 */
	function chart(selection) {
		selection.each(function() {

			if (!width) width = this.offsetWidth

			let fn_xScale = d3
				.scaleBand()
				.range([padding.left, width - padding.right])
				.domain(fullData.map(fn_key))
				//.round(true)
				.paddingInner(padding.inner)
				.paddingOuter(padding.outer)

			let fn_yScale = d3
				.scaleLinear()
				.range([height - padding.bottom, padding.top])
				.domain(fn_getYDomain());

			let fn_barScale = d3
				.scaleLinear()
				.range([0, height - padding.top - padding.bottom])
				.domain(fn_getYDomain());

			fn_xAxis.scale(fn_xScale)
				.tickSizeOuter(0)
				.tickValues(fn_xScale.domain().filter(
					(d, i) => !(i % Math.round(fullData.length / 10)) // only 10 ticks displayed
				))

			fn_yAxis.scale(fn_yScale)
				.tickSizeOuter(0);

			let svg = d3
				.select(this)
				.append("svg")
				.attr("width", width)
				.attr("height", height);

			// initialization of barsInfo, will be used in the barBrusher.js
			let barsInfo = fullData.map(() => { return { center: null, extent: null, key: null, bars: [] } })

			let fn_initSingleBar = function(selection, v, j) {
				selection.each(function (d, i) {

					let bar = d3.select(this)
					let x0 = fn_xScale(fn_key(d, i))
					let width = fn_xScale.bandwidth()
					let x1 = x0 + width

					// brushed and unbrushed are events generated by the barBrusher
					bar.on("unbrushed", (d, i, nodes) => d3.select(nodes[i]).style("fill", "lightgray") )
						.on("brushed", (d, i, nodes) => d3.select(nodes[i]).style("fill", fn_color(v, j, d, i)) )
						.attr("x", x0)
						.attr("y", fn_yScale(Object.byString(d, v)))
						.attr("width", width)
						.attr("height", fn_barScale(Object.byString(d, v)))
						.style("fill", fn_color(v, j, d, i))
						.style("fill-opacity", fn_areaOpacity(v, j))

					barsInfo[i].center = barsInfo[i].center || (x0 + x1)/2;
					barsInfo[i].extent = barsInfo[i].extent || [ x0, x1 ];
					barsInfo[i].key = barsInfo[i].key || fn_key(d, i);
					barsInfo[i].bars.push(bar)

				})
			}

			let fn_updateSingleBar = function(selection, v, j) {
				selection.each(function (d, i) {
					
					let x0 = fn_xScale(fn_key(d, i))
					let width = fn_xScale.bandwidth()
					let x1 = x0 + width

					d3.select(this)
						.attr("x", x0)
						.attr("width", width)

					barsInfo[i].center = (x0 + x1)/2;
					barsInfo[i].extent = [ x0, x1 ];
				
				})
			}	

			let fn_initBars = function(selection) {
				selection.each(function (v, j) {
					let gBars = d3.select(this)

					gBars.selectAll("rect.bar")
						.data(fullData, fn_key)
						.enter()
						.append("rect")
						.classed("bar", true)
						.call(fn_initSingleBar, v, j)

				})
			}

			let fn_updateBars = function(selection) {
				selection.each(function (v, j) {
					let gBars = d3.select(this)
						.selectAll("rect.bar")
						.call(fn_updateSingleBar, v, j)
				})
			}

			svg.selectAll("g.bars")
				.data(values)
				.enter()
				.append("g")
				.classed("bars", true)
				.call(fn_initBars)


			// init the bar brusher
			let bBrusher = barBrusher()
				.width(width - padding.right - padding.left) // adjust it if the xScale is ROUND
				.height(height - padding.top - padding.bottom)
				.x(padding.left) // adjust it if the xScale is ROUND
				.y(padding.top)
				.barsInfo(barsInfo) // the info to handle the bars
				.fn_brushingCallback(fn_brushingCallback)
				.fn_brushEndCallback(fn_brushEndCallback)

			svg.call(bBrusher)

			let xAxis = svg
				.append("g")
				.classed("x-axis", true)
				.attr(
					"transform",
					"translate(0, " + (height - padding.bottom) + ")"
				);

			let yAxis = svg
				.append("g")
				.classed("y-axis", true)
				.attr("transform", "translate(" + padding.left + ", 0)")

			xAxis.call(fn_xAxis);
			yAxis.call(fn_yAxis);


			fn_updateWidth = () => {

				width = this.offsetWidth

				svg.attr("width", width)

				fn_xScale.range([padding.left, width - padding.right])

				svg.selectAll("g.bars")
					.call(fn_updateBars)

				bBrusher.width(width - padding.right - padding.left)

				xAxis.call(fn_xAxis);	
			
			}	

			/*
			 *	Function called if new data comes.
			 */
			fn_updateFullData = function() {

				//TODO, needed??
				/*
				fn_xScale.domain(d3.extent(fullData, fn_key));

				fn_yScale.domain(fn_getYDomain());
				fn_barScale.domain(fn_getYDomain());

				fn_xAxis.tickValues(fn_xScale.domain());

				xAxis.transition().call(fn_xAxis);
				yAxis.transition().call(fn_yAxis);
				*/
			};
		});
	}

	/*
	 *	GETTERS/SETTERS
	 */
	chart.width = function(value) {
		if (!arguments.length) return width;
		width = value;
		return chart;
	};

	chart.updateWidth = function() {
		if (typeof fn_updateWidth === "function") fn_updateWidth()
		return chart;
	}

	chart.height = function(value) {
		if (!arguments.length) return height;
		height = value;
		return chart;
	};

	chart.padding = function(value) {
		if (!arguments.length) return padding;
		padding = value;
		return chart;
	};

	chart.fn_color = function(value) {
		if (!arguments.length) return fn_color;
		fn_color = value;
		return chart;
	};

	chart.fn_areaOpacity = function(value) {
		if (!arguments.length) return fn_areaOpacity;
		fn_areaOpacity = value;
		return chart;
	};

	chart.fn_key = function(value) {
		if (!arguments.length) return fn_key;
		fn_key = value;
		return chart;
	};

	chart.values = function(value) {
		if (!arguments.length) return values;
		values = value;
		return chart;
	};

	chart.fn_xAxis = function(value) {
		if (!arguments.length) return fn_xAxis;
		fn_xAxis = value;
		return chart;
	};

	chart.fn_yAxis = function(value) {
		if (!arguments.length) return fn_yAxis;
		fn_yAxis = value;
		return chart;
	};

	chart.fullData = function(value) {
		if (!arguments.length) return fullData;
		fullData = value;
		if (typeof fn_updateFullData === "function") fn_updateFullData();
		return chart;
	};

	chart.fn_brushingCallback = function(value) {
		if (!arguments.length) return fn_brushingCallback;
		fn_brushingCallback = value;
		return chart;
	}

	chart.fn_brushEndCallback = function(value) {
		if (!arguments.length) return fn_brushEndCallback;
		fn_brushEndCallback = value;
		return chart;
	}

	return chart;
}
